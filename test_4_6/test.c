////////////////////////挺重要的////////////////////////////////////////////////////////////////////////////////////////
 ///////////////////////写一个函数求a的二进制（补码）中有几个1//////////////////////////////////////////////////////////
//////////////////////////////////////////三种方法//////////////////////////////////////////////////////////////////////
#include<stdio.h>

//方法一 
//n=-1,把-1的符号位转为无符号位，unsigned
int count_bit_one(unsigned int n)
{
	int count = 0;
	while (n)
	{
		if (n % 2 == 1)
		{
			count++;
		}
		
		
		n = n / 2;
		
	}
	return count;
}
//方法二  
//n=13    00000000000000000000000000001101
//        00000000000000000000000000000001
int count_bit_one( int n)
{
	int count = 0;
	int i = 0;
	for (i = 0; i < 32; i++)
	{
		if (((n >> i) & 1) == 1)
		{
			count++;

		}
			
	}
	return count;
}

//方法三  比较高效
//n=13 1101
//n-1  1100  n&(n-1)  1100 赋给n  少了一个1
//此时n 1100
//n-1   1011  n&(n-1) 1000 赋给n  又少了一个1
//此时n 1000
//n-1   0111  n&(n-1) 0000        又少了一个1
int count_bit_one(int n)
{
	int count = 0;
	while (n)
	{
		n = n&(n - 1);
		count++;
	}
	return count;
}
int main()
{
	int a = 0;
	
	scanf_s("%d", &a);
	//写一个函数求a的二进制（补码）中有几个1
	int count = count_bit_one(a);
	printf("count=:%d\n", count);
	return 0;
}
